import { benefits } from "../constants/index";
import Heading from "./Heading";
import Section from "./Section";
import Arrow from "../assets/svg/Arrow";
import ClipPath from "../assets/svg/ClipPath";
import { GradientLight } from "./design/Benefits";
import UploadButton from "./UploadButton";
import { useState, useEffect } from "react";
import {
  useContract,
  useContractWrite,
  useContractRead,
  useAddress,
} from "@thirdweb-dev/react";
import { MissingGasInnerError } from "web3";
import { benefitIcon2, benefitIcon3, benefitImage2 } from "../assets";
import { IoCloseSharp } from "react-icons/io5";
import { imgFile } from "../assets";
import axios from "axios";

const CONTRACT_ADDRESS =
  import.meta.env.VITE_CONTRACT_ADDRESS ||
  "0xa3056456Ff179DF495B6a4301C0342F49ccEF87e";

const Dashboard = () => {
  const { contract, isLoading } = useContract(CONTRACT_ADDRESS);
  const address = useAddress();
  console.log(address);
  const [msg, setMsg] = useState([]);
  const [isPopupOpen, setIsPopupOpen] = useState(false);
  const [selectedImage, setSelectedImage] = useState(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [aiAnalysis, setAiAnalysis] = useState(null);
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [deletedDocs, setDeletedDocs] = useState([]);
  const [docMetadata, setDocMetadata] = useState({});
  const [isLoadingDocs, setIsLoadingDocs] = useState(true);
  const [loadingMessage, setLoadingMessage] = useState("");

  // Multiple IPFS gateways for fallback
  const IPFS_GATEWAYS = [
    'https://gateway.pinata.cloud/ipfs/',
    'https://cloudflare-ipfs.com/ipfs/',
    'https://ipfs.io/ipfs/',
    'https://dweb.link/ipfs/'
  ];

  // Function to fetch metadata from IPFS with multiple gateway fallbacks
  const fetchMetadataFromIPFS = async (cid, metadataCid) => {
    // Try each gateway with a short timeout
    for (const gateway of IPFS_GATEWAYS) {
      try {
        const response = await axios.get(`${gateway}${metadataCid}`, {
          timeout: 5000 // 5 second timeout per gateway
        });
        console.log(`‚úÖ Fetched metadata from ${gateway} for ${cid.substring(0, 20)}...`);
        return response.data;
      } catch (error) {
        console.log(`‚ö†Ô∏è Failed to fetch from ${gateway}, trying next...`);
        continue; // Try next gateway
      }
    }
    console.error(`‚ùå All IPFS gateways failed for ${metadataCid}`);
    return null;
  };

  // Load metadata - PRIORITIZE localStorage, use IPFS only as fallback
  const loadAllMetadata = async (documents) => {
    if (!address) return;

    // Load from localStorage as PRIMARY source
    const localMetadata = JSON.parse(
      localStorage.getItem(`docMetadata_${address}`) || "{}"
    );
    console.log(`üì¶ Loaded ${Object.keys(localMetadata).length} metadata entries from localStorage`);
    
    const mergedMetadata = { ...localMetadata };

    // Only try IPFS if localStorage is completely empty for a document
    // This prevents IPFS failures from wiping existing metadata
    for (const doc of documents) {
      // Skip if we already have metadata in localStorage
      if (mergedMetadata[doc.cid]) {
        console.log(`‚úÖ Using cached metadata for ${doc.cid.substring(0, 20)}...`);
        continue;
      }

      // Only try IPFS fetch if no localStorage metadata exists
      console.log(`üîç No cached metadata for ${doc.cid.substring(0, 20)}..., trying IPFS...`);
      try {
        const metadataCid = `${doc.cid}_metadata`;
        const ipfsMetadata = await fetchMetadataFromIPFS(doc.cid, metadataCid);
        if (ipfsMetadata) {
          mergedMetadata[doc.cid] = ipfsMetadata;
          console.log(`‚úÖ Found metadata on IPFS for ${doc.cid.substring(0, 20)}...`);
        } else {
          console.log(`‚ÑπÔ∏è No IPFS metadata found for ${doc.cid.substring(0, 20)}...`);
        }
      } catch (error) {
        // Metadata not found on IPFS, that's okay - don't show as error
        console.log(`‚ÑπÔ∏è Could not fetch IPFS metadata for ${doc.cid.substring(0, 20)}...`);
      }
    }

    setDocMetadata(mergedMetadata);
    console.log(`üìä Final metadata count: ${Object.keys(mergedMetadata).length}`);

    // Update localStorage with any new metadata found from IPFS
    localStorage.setItem(
      `docMetadata_${address}`,
      JSON.stringify(mergedMetadata)
    );

    return mergedMetadata;
  };

  // Load deleted documents and metadata from localStorage on mount
  useEffect(() => {
    if (address) {
      const stored = localStorage.getItem(`deletedDocs_${address}`);
      if (stored) {
        setDeletedDocs(JSON.parse(stored));
      }

      // Load document metadata
      const metadata = localStorage.getItem(`docMetadata_${address}`);
      if (metadata) {
        setDocMetadata(JSON.parse(metadata));
      }
    }
  }, [address]);

  useEffect(() => {
    const fetchData = async () => {
      if (!isLoading && contract && address) {
        try {
          setIsLoadingDocs(true);
          setLoadingMessage("üì° Connecting to blockchain...");

          // SIMPLIFIED: Only show files uploaded directly from Document Sentinel
          // Transferred files will be shown in Document Transfer page instead
          const uploadedData = await contract.call("getFiles", [address]);
          console.log("ÔøΩ Documents uploaded from Document Sentinel:", uploadedData.length);
          console.log("ÔøΩ Uploaded documents:", uploadedData.map(d => ({ 
            cid: d.cid?.substring(0, 20) + '...',
            receiver: d.receiver?.substring(0, 10) + '...'
          })));

          setLoadingMessage("üîç Filtering and sorting documents...");

          // Sort by timestamp - newest first (descending order)
          const sortedData = [...uploadedData].sort((a, b) => {
            const timestampA = bytes32ToDecimal(a.timestamp);
            const timestampB = bytes32ToDecimal(b.timestamp);
            return Number(timestampB) - Number(timestampA); // Newest first
          });

          // Filter out deleted documents
          const filtered = sortedData.filter(
            (doc) => !deletedDocs.includes(doc.cid)
          );
          
          console.log("üîç Before filtering - Total documents:", sortedData.length);
          console.log("üîç Deleted docs CIDs to filter out:", deletedDocs);
          console.log("üîç After filtering - Visible documents:", filtered.length);
          
          setMsg(filtered);
          console.log(
            "‚úÖ Documents to display:",
            filtered.length,
            "(hidden:",
            deletedDocs.length,
            ")"
          );
          console.log("‚úÖ Final document CIDs to display:", filtered.map(d => d.cid?.substring(0, 20) + '...'));
          
          // Debug: Show what's being hidden
          if (deletedDocs.length > 0) {
            console.log("üóëÔ∏è Hidden document CIDs:", deletedDocs);
            const hiddenDocs = sortedData.filter(doc => deletedDocs.includes(doc.cid));
            console.log("üóëÔ∏è Hidden documents details:", hiddenDocs.map(d => ({ cid: d.cid.substring(0, 20), isReceived: d.isReceived })));
          }

          // FIXED: Only use localStorage metadata, NEVER try IPFS (it's always failing)
          setLoadingMessage("üìã Loading patient information...");
          
          const currentMetadata = JSON.parse(
            localStorage.getItem(`docMetadata_${address}`) || "{}"
          );
          
          console.log(`üì¶ Metadata in localStorage: ${Object.keys(currentMetadata).length} entries`);
          
          if (Object.keys(currentMetadata).length === 0 && filtered.length > 0) {
            // No metadata in localStorage - SKIP IPFS (it's always failing)
            console.warn("‚ö†Ô∏è No metadata found in localStorage. Patient info will not be displayed.");
            console.warn("üí° To add metadata: Upload documents with patient info filled in the 'Document Transfer' page");
            setDocMetadata({});
          } else {
            // Use localStorage metadata
            console.log(`‚úÖ Using ${Object.keys(currentMetadata).length} metadata entries from localStorage`);
            setDocMetadata(currentMetadata);
          }

          setIsLoadingDocs(false);
          setLoadingMessage("");
        } catch (error) {
          console.error("Error loading documents:", error);
          setIsLoadingDocs(false);
          setLoadingMessage("");
        }
      }
    };
    fetchData();
  }, [address, contract, isLoading, deletedDocs]);

  const handleBoxClick = async (item) => {
    try {
      console.log("Opening document with CID:", item.cid);
      // Use public IPFS gateway
      const url = `https://ipfs.io/ipfs/${item.cid}`;
      window.open(url, "_blank");
    } catch (error) {
      console.error("Error opening document:", error);
      alert("Failed to open document");
    }
  };

  const handlePopupClose = () => {
    setIsPopupOpen(false);
    window.location.reload();
    setSelectedImage(null);
  };

  const handleAnalyzeWithAI = async (item, event) => {
    event.stopPropagation(); // Prevent opening the document

    setSelectedDocument(item);
    setIsAnalyzing(true);
    setAiAnalysis(null);
    setIsPopupOpen(true);

    try {
      console.log("Analyzing document with CID:", item.cid);

      // Fetch the image from IPFS
      const imageUrl = `https://ipfs.io/ipfs/${item.cid}`;

      // Convert image to base64 for Gemini Vision API
      const response = await fetch(imageUrl);
      const blob = await response.blob();

      // Check if it's an image
      if (!blob.type.startsWith("image/")) {
        setAiAnalysis({
          error: true,
          message:
            "‚ö†Ô∏è This file is not an image. AI analysis is currently only available for medical images (X-rays, CT scans, MRI, etc.)",
        });
        setIsAnalyzing(false);
        return;
      }

      const reader = new FileReader();
      reader.readAsDataURL(blob);

      reader.onloadend = async () => {
        const base64Image = reader.result.split(",")[1];

        // List of models to try (in order of preference)
        const modelsToTry = [
          "gemini-1.5-flash-latest",
          "gemini-1.5-pro-latest",
          "gemini-pro-vision",
        ];

        let lastError = null;
        let success = false;

        for (const modelName of modelsToTry) {
          if (success) break;

          try {
            console.log(`Trying model: ${modelName}...`);

            const geminiResponse = await axios.post(
              `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=AIzaSyBGe74bxJu3TrJZqvVK3JpWBVXjYC-PkVc`,
              {
                contents: [
                  {
                    parts: [
                      {
                        text: `You are an expert medical radiologist AI assistant. Analyze this medical imaging scan and provide a detailed professional report.

Please structure your analysis as follows:

**1. IMAGE IDENTIFICATION**
- Type of scan (X-ray, CT, MRI, Ultrasound, etc.)
- Anatomical region/body part shown
- Imaging plane (if applicable: AP, lateral, axial, sagittal, coronal)
- Image quality assessment

**2. TECHNICAL PARAMETERS**
- Exposure and contrast evaluation
- Positioning adequacy
- Any technical limitations or artifacts

**3. ANATOMICAL FINDINGS**
- Normal anatomical structures visible
- Bone/soft tissue/organ appearances
- Symmetry and alignment
- Size and position of structures

**4. PATHOLOGICAL FINDINGS** (if any)
- Abnormalities detected
- Location and characteristics
- Size and extent of any lesions
- Comparison with normal anatomy

**5. RADIOLOGICAL INTERPRETATION**
- Primary diagnostic impression
- Differential diagnoses (if applicable)
- Severity assessment (if applicable)

**6. CLINICAL RECOMMENDATIONS**
- Suggested follow-up imaging
- Additional tests recommended
- Urgency level (routine, urgent, emergency)
- Specialist consultation if needed

**7. LIMITATIONS**
- Any factors limiting interpretation
- Need for comparison with prior studies

Be specific, use proper medical terminology, and provide detailed observations. If you cannot identify specific pathology, describe what you DO see in detail.`,
                      },
                      {
                        inline_data: {
                          mime_type: blob.type,
                          data: base64Image,
                        },
                      },
                    ],
                  },
                ],
                generationConfig: {
                  temperature: 0.3,
                  topK: 40,
                  topP: 0.95,
                  maxOutputTokens: 2048,
                },
                safetySettings: [
                  {
                    category: "HARM_CATEGORY_HARASSMENT",
                    threshold: "BLOCK_NONE",
                  },
                  {
                    category: "HARM_CATEGORY_HATE_SPEECH",
                    threshold: "BLOCK_NONE",
                  },
                  {
                    category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    threshold: "BLOCK_NONE",
                  },
                  {
                    category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                    threshold: "BLOCK_NONE",
                  },
                ],
              },
              {
                timeout: 60000,
              }
            );

            console.log(`Success with model: ${modelName}`);
            console.log("Full Gemini response:", geminiResponse.data);

            if (geminiResponse.data?.candidates?.[0]) {
              const candidate = geminiResponse.data.candidates[0];

              if (candidate.finishReason === "SAFETY") {
                console.warn("Content blocked by safety filters");
                setAiAnalysis({
                  error: true,
                  message: `‚ö†Ô∏è **Analysis Blocked by Safety Filters**
                  
The AI safety system blocked the analysis. This can happen with medical images due to content policies.

**Workaround Options:**
1. Try a different medical image
2. Ensure the image is clearly a diagnostic scan (not photos of injuries)
3. Use professional DICOM viewer software for detailed analysis
4. Consult with a radiologist directly

**Note:** Medical AI analysis requires specialized tools and may not be available through free consumer APIs.`,
                });
                setIsAnalyzing(false);
                return;
              }

              if (candidate.content?.parts?.[0]?.text) {
                const analysisText = candidate.content.parts[0].text;

                const fullReport = `${analysisText}

---

**‚ö†Ô∏è CRITICAL MEDICAL DISCLAIMER**

This AI-generated analysis is provided for educational and informational purposes only. 

**THIS IS NOT A MEDICAL DIAGNOSIS**

‚Ä¢ This report must be reviewed and verified by a licensed radiologist
‚Ä¢ Do not make medical decisions based solely on this AI analysis
‚Ä¢ Always consult qualified healthcare professionals for diagnosis and treatment
‚Ä¢ In medical emergencies, seek immediate professional care
‚Ä¢ AI can make errors - human expert review is essential

**Legal Notice:** This analysis does not establish a doctor-patient relationship and should not replace professional medical consultation.

---

**Report Generated:** ${new Date().toLocaleString()}
**Analysis Method:** AI-Assisted (${modelName})
**Status:** PRELIMINARY - Requires Professional Radiologist Review`;

                setAiAnalysis({
                  error: false,
                  message: fullReport,
                  imageUrl: imageUrl,
                });
                success = true;
                setIsAnalyzing(false);
                return;
              }
            }
          } catch (modelError) {
            console.error(
              `Model ${modelName} failed:`,
              modelError.response?.data || modelError.message
            );
            lastError = modelError;
            // Continue to next model
          }
        }

        // If all models failed, show error
        if (!success) {
          const status = lastError?.response?.status;
          const errorData = lastError?.response?.data?.error;

          let errorMessage = `‚ö†Ô∏è **Unable to Analyze Medical Image**\n\n`;

          if (status === 404) {
            errorMessage += `**Issue:** Gemini Vision models not available for your API key\n\n`;
            errorMessage += `**Details:** ${
              errorData?.message ||
              "Vision models may not be enabled for free tier"
            }\n\n`;
            errorMessage += `**Solutions:**\n`;
            errorMessage += `1. **Check your API key** at https://aistudio.google.com/app/apikey\n`;
            errorMessage += `2. **Enable Gemini 1.5 models** in your Google AI Studio project\n`;
            errorMessage += `3. **Create a new API key** with vision access\n`;
            errorMessage += `4. **Consider upgrading** to paid tier for full vision support\n`;
          } else if (status === 403) {
            errorMessage += `**Issue:** API Key Limitation\n\n`;
            errorMessage += `Your API key may not have access to vision features.\n\n`;
            errorMessage += `**Solutions:**\n`;
            errorMessage += `1. **Enable billing** in Google AI Studio\n`;
            errorMessage += `2. **Create new API key** with vision capabilities\n`;
            errorMessage += `3. **Check quota** at https://aistudio.google.com/app/apikey\n`;
          } else {
            errorMessage += `**Error:** ${
              errorData?.message || lastError?.message || "Unknown error"
            }\n`;
            errorMessage += `**Status Code:** ${status || "Network Error"}\n`;
          }

          errorMessage += `\n---\n\n`;
          errorMessage += `**Alternative Options for Medical Image Analysis:**\n\n`;
          errorMessage += `1. **Professional Radiology Services** - Most reliable\n`;
          errorMessage += `2. **Hospital PACS Systems** - For official medical records\n`;
          errorMessage += `3. **Telemedicine Platforms** - Remote radiologist consultation\n`;
          errorMessage += `4. **Medical Imaging Software** - DICOM viewers with AI plugins\n`;

          setAiAnalysis({
            error: true,
            message: errorMessage,
          });
          setIsAnalyzing(false);
        }
      };

      reader.onerror = () => {
        setAiAnalysis({
          error: true,
          message: "Failed to load image from IPFS. Please try again.",
        });
        setIsAnalyzing(false);
      };
    } catch (error) {
      console.error("Error analyzing document:", error);
      setAiAnalysis({
        error: true,
        message:
          "Failed to analyze document. Please ensure it's a valid medical image.",
      });
      setIsAnalyzing(false);
    }
  };

  const handleCloseAnalysis = () => {
    setIsPopupOpen(false);
    setAiAnalysis(null);
    setSelectedDocument(null);
    setIsAnalyzing(false);
  };

  const handleDeleteDocument = (item, event) => {
    event.stopPropagation(); // Prevent opening the document

    const confirmDelete = window.confirm(
      `Are you sure you want to delete this document?\n\nCID: ${item.cid.substring(
        0,
        30
      )}...\n\nNote: This will hide the document from your view. The document will still exist on the blockchain and IPFS.`
    );

    if (confirmDelete) {
      // Add to deleted list
      const newDeletedDocs = [...deletedDocs, item.cid];
      setDeletedDocs(newDeletedDocs);

      // Save to localStorage
      localStorage.setItem(
        `deletedDocs_${address}`,
        JSON.stringify(newDeletedDocs)
      );

      // Update the displayed documents
      const filteredDocs = msg.filter((doc) => doc.cid !== item.cid);
      setMsg(filteredDocs);

      alert("‚úÖ Document deleted from your view successfully!");
    }
  };

  const handleRestoreDeleted = () => {
    const confirmRestore = window.confirm(
      `Are you sure you want to restore all deleted documents?\n\nThis will show ${deletedDocs.length} hidden documents again.`
    );

    if (confirmRestore) {
      // Clear deleted list
      console.log('üîÑ Restoring all deleted documents...');
      setDeletedDocs([]);
      localStorage.removeItem(`deletedDocs_${address}`);

      // Refresh to show all documents
      handleRefresh();

      alert("‚úÖ All deleted documents have been restored!");
    }
  };

  const handleClearAllCache = () => {
    const confirmClear = window.confirm(
      `‚ö†Ô∏è WARNING: This will clear ALL document caches including:\n\n` +
      `‚Ä¢ Hidden documents list (${deletedDocs.length} items)\n` +
      `‚Ä¢ Document metadata\n` +
      `‚Ä¢ Received files cache\n\n` +
      `Documents on blockchain will NOT be deleted.\n\n` +
      `Continue?`
    );

    if (confirmClear) {
      console.log('üßπ Clearing all localStorage caches for address:', address);
      localStorage.removeItem(`deletedDocs_${address}`);
      localStorage.removeItem(`docMetadata_${address}`);
      localStorage.removeItem(`receivedFiles_${address}`);
      setDeletedDocs([]);
      setDocMetadata({});
      alert("‚úÖ All caches cleared! Page will reload.");
      window.location.reload();
    }
  };

  const handleShowCacheInfo = () => {
    // Debug function to show what's in localStorage
    const deletedDocsCache = JSON.parse(localStorage.getItem(`deletedDocs_${address}`) || "[]");
    const metadataCache = JSON.parse(localStorage.getItem(`docMetadata_${address}`) || "{}");
    const receivedFilesCache = JSON.parse(localStorage.getItem(`receivedFiles_${address}`) || "[]");
    
    const metadataCIDs = Object.keys(metadataCache);
    
    console.log("üìä === CACHE DEBUG INFO ===");
    console.log("Address:", address);
    console.log("Deleted docs:", deletedDocsCache.length, deletedDocsCache);
    console.log("Metadata entries:", metadataCIDs.length, metadataCIDs.map(cid => cid.substring(0, 20) + "..."));
    console.log("Received files:", receivedFilesCache.length, receivedFilesCache.map(f => ({ cid: f.cid?.substring(0, 20) + "...", sender: f.sender?.substring(0, 10) + "..." })));
    console.log("Full metadata:", metadataCache);
    console.log("========================");
    
    alert(
      `üìä Cache Information:\n\n` +
      `üóëÔ∏è Hidden documents: ${deletedDocsCache.length}\n` +
      `üìã Metadata entries: ${metadataCIDs.length}\n` +
      `üì• Received files: ${receivedFilesCache.length}\n` +
      `üìÑ Visible documents: ${msg.length}\n\n` +
      `Check console for detailed info`
    );
  };

  const bytes32ToDecimal = (bytes32Hex) => {
    if (bytes32Hex.startsWith("0x")) {
      bytes32Hex = bytes32Hex.slice(2);
    }
    let result = BigInt("0x" + bytes32Hex);
    return result.toString();
  };

  const decimalToUTC = (decimalTimestamp) => {
    const timestampMilliseconds = decimalTimestamp * 1000;
    const date = new Date(timestampMilliseconds);
    const utcString = date.toUTCString();
    return utcString;
  };

  // Convert either bytes32 timestamp or numeric timestamp (seconds) to IST string
  const convertUTC = (value) => {
    try {
      let seconds = 0;
      if (typeof value === "string" && value.startsWith("0x")) {
        // bytes32 hex
        seconds = Number(bytes32ToDecimal(value));
      } else if (typeof value === "string" && /^[0-9]+$/.test(value)) {
        seconds = Number(value);
      } else if (typeof value === "number") {
        seconds = value;
      } else if (value && value._hex) {
        // ethers BigNumber
        seconds = Number(
          value._hex ? BigInt(value._hex).toString() : value.toString()
        );
      } else {
        return "Unknown time";
      }

      const utcDate = new Date(seconds * 1000);
      const istDate = utcDate.toLocaleString("en-US", {
        timeZone: "Asia/Kolkata",
      });
      return istDate;
    } catch (err) {
      console.error("convertUTC error:", err);
      return "Invalid time";
    }
  };

  const handleRefresh = async () => {
    try {
      if (!isLoading && contract && address) {
        setIsLoadingDocs(true);
        setLoadingMessage("üîÑ Refreshing documents...");

        console.log("üîÑ Refreshing documents for address:", address);
        setLoadingMessage("üì° Connecting to blockchain...");

        // SIMPLIFIED: Only get files uploaded directly from Document Sentinel
        const uploadedData = await contract.call("getFiles", [address]);
        console.log("üì§ Documents uploaded from Document Sentinel:", uploadedData.length);

        setLoadingMessage("üîç Filtering and sorting documents...");

        // Sort by timestamp - newest first
        const sortedData = [...uploadedData].sort((a, b) => {
          const timestampA = bytes32ToDecimal(a.timestamp);
          const timestampB = bytes32ToDecimal(b.timestamp);
          return Number(timestampB) - Number(timestampA);
        });

        // Filter out deleted documents
        const filtered = sortedData.filter((doc) => !deletedDocs.includes(doc.cid));
        setMsg(filtered);

        // Reload metadata from localStorage
        setLoadingMessage("üìã Loading patient information from cache...");
        const cachedMetadata = JSON.parse(localStorage.getItem(`docMetadata_${address}`) || "{}");
        setDocMetadata(cachedMetadata);

        setIsLoadingDocs(false);
        setLoadingMessage("");

        alert(
          `‚úÖ Refreshed! Found ${filtered.length} documents\n\nüì§ Uploaded: ${uploadedData.length}\nüóëÔ∏è Hidden: ${deletedDocs.length}\nüìã Metadata: ${Object.keys(cachedMetadata).length} cached`
        );
      }
    } catch (error) {
      console.error("Error refreshing documents:", error);
      setIsLoadingDocs(false);
      setLoadingMessage("");
      alert("Failed to refresh documents: " + error.message);
    }
  };
        setLoadingMessage("ÔøΩ Checking for received documents...");

        // Use localStorage to track received files (populated when someone transfers to you)
        const receivedFilesCache = JSON.parse(
          localStorage.getItem(`receivedFiles_${address}`) || "[]"
        );
        console.log("ÔøΩ Received files from cache:", receivedFilesCache.length);

        // Convert cached received files to proper format
        const receivedFiles = receivedFilesCache.map((item) => ({
          cid: item.cid,
          receiver: item.receiver || address,
          timestamp: item.timestamp || "0x0",
          isReceived: true,
        }));

        // Combine uploaded and received files
        const allFiles = [...uploadedData, ...receivedFiles];

        // Deduplicate by CID (in case same file appears multiple times)
        const uniqueFiles = Array.from(
          new Map(allFiles.map((item) => [item.cid, item])).values()
        );

        console.log(
          "üìã Total unique documents:",
          uniqueFiles.length,
          "(Uploaded:",
          uploadedData.length,
          "+ Received:",
          receivedFiles.length,
          ")"
        );

        setLoadingMessage("üîç Filtering and sorting documents...");

        // Sort by timestamp - newest first (descending order)
        const sortedData = [...uniqueFiles].sort((a, b) => {
          const timestampA = bytes32ToDecimal(a.timestamp);
          const timestampB = bytes32ToDecimal(b.timestamp);
          return Number(timestampB) - Number(timestampA); // Newest first
        });

        // Filter out deleted documents
        const filtered = sortedData.filter(
          (doc) => !deletedDocs.includes(doc.cid)
        );
        setMsg(filtered);
        console.log(
          "‚úÖ Documents to display:",
          filtered.length,
          "(hidden:",
          deletedDocs.length,
          ")"
        );

        // FIXED: Only reload metadata from localStorage on Refresh, don't try IPFS
        // This prevents IPFS timeout errors and is much faster
        setLoadingMessage("üìã Loading patient information from cache...");
        const cachedMetadata = JSON.parse(
          localStorage.getItem(`docMetadata_${address}`) || "{}"
        );
        console.log(`üì¶ Loaded ${Object.keys(cachedMetadata).length} metadata entries from localStorage`);
        setDocMetadata(cachedMetadata);

        setIsLoadingDocs(false);
        setLoadingMessage("");

        alert(
          `‚úÖ Refreshed! Found ${filtered.length} documents\n\nüì§ Uploaded: ${uploadedData.length}\nÔ∏è Hidden: ${deletedDocs.length}\nüìã Metadata: ${Object.keys(cachedMetadata).length} cached`
        );
      }
    } catch (error) {
      console.error("Error refreshing documents:", error);
      setIsLoadingDocs(false);
      setLoadingMessage("");
      alert("Failed to refresh documents: " + error.message);
    }
  };

  return (
    <Section id="features" className="min-h-screen">
      <UploadButton className="fixed bottom-4 right-4 z-100" />
      <div className="container relative z-2">
        <div className="flex justify-between items-center mb-8 flex-wrap gap-4">
          <Heading
            className="md:max-w-md lg:max-w-2xl"
            title="Your secured documents"
          />
          <div className="flex gap-3">
            {deletedDocs.length > 0 && (
              <button
                onClick={handleRestoreDeleted}
                className="px-6 py-3 bg-gradient-to-r from-green-500 to-green-700 text-white font-bold rounded-lg hover:from-green-600 hover:to-green-800 transition-all shadow-lg animate-pulse"
                title="Click to show hidden documents"
              >
                üîÑ Restore {deletedDocs.length} Hidden
              </button>
            )}
            <button
              onClick={handleShowCacheInfo}
              className="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-700 text-white font-bold rounded-lg hover:from-blue-600 hover:to-blue-800 transition-all"
              title="Show localStorage cache information (debugging)"
            >
              üìä Cache Info
            </button>
            <button
              onClick={handleClearAllCache}
              className="px-6 py-3 bg-gradient-to-r from-red-500 to-red-700 text-white font-bold rounded-lg hover:from-red-600 hover:to-red-800 transition-all"
              title="Clear all local caches (debugging)"
            >
              üßπ Clear Cache
            </button>
            <button
              onClick={handleRefresh}
              className="px-6 py-3 bg-gradient-to-r from-orange-500 to-orange-700 text-white font-bold rounded-lg hover:from-orange-600 hover:to-orange-800 transition-all"
            >
              Refresh Documents
            </button>
          </div>
        </div>

        {/* Loading Indicator */}
        {isLoadingDocs && (
          <div className="flex flex-col items-center justify-center py-20">
            <div className="relative">
              <div className="w-20 h-20 border-4 border-purple-200 border-t-purple-600 rounded-full animate-spin"></div>
              <div className="absolute inset-0 flex items-center justify-center">
                <span className="text-2xl">üìÑ</span>
              </div>
            </div>
            <p className="mt-6 text-lg font-semibold text-white">
              {loadingMessage}
            </p>
            <p className="mt-2 text-sm text-gray-400">
              Please wait while we fetch your documents...
            </p>
          </div>
        )}

        {/* Empty State with Helpful Message */}
        {!isLoadingDocs && msg.length === 0 && (
          <div className="text-center py-20 bg-zinc-900 rounded-lg border border-zinc-700">
            <div className="text-6xl mb-4">üì≠</div>
            <p className="text-gray-400 text-xl mb-2">No documents found</p>
            <p className="text-gray-500 mt-2">
              Click the{" "}
              <span className="text-orange-500 font-semibold">Upload</span>{" "}
              button to add your first document
            </p>

            {/* Just Uploaded Help Text */}
            <div className="mt-8 max-w-md mx-auto bg-blue-900/30 border border-blue-500/50 rounded-lg p-6">
              <p className="text-blue-300 font-semibold mb-2">
                üí° Just uploaded a document?
              </p>
              <p className="text-sm text-blue-200 mb-3">
                Blockchain transactions take ~30 seconds to confirm.
              </p>
              <div className="space-y-2 text-left text-sm text-gray-300">
                <p className="flex items-start gap-2">
                  <span className="text-green-400">‚úì</span>
                  <span>Wait 30-60 seconds after upload</span>
                </p>
                <p className="flex items-start gap-2">
                  <span className="text-green-400">‚úì</span>
                  <span>Click "Refresh Documents" button above</span>
                </p>
                <p className="flex items-start gap-2">
                  <span className="text-green-400">‚úì</span>
                  <span>Check MetaMask for transaction confirmation</span>
                </p>
              </div>
            </div>

            {/* Received Documents Help Text */}
            <div className="mt-6 max-w-md mx-auto bg-green-900/20 border border-green-500/40 rounded-lg p-6">
              <p className="text-green-300 font-semibold mb-2">
                üì• Expecting a transferred document?
              </p>
              <p className="text-sm text-green-200 mb-3">
                Documents transferred to you will appear here automatically.
              </p>
              <div className="space-y-2 text-left text-sm text-gray-300">
                <p className="flex items-start gap-2">
                  <span className="text-green-400">‚úì</span>
                  <span>Make sure you're using the same wallet & browser</span>
                </p>
                <p className="flex items-start gap-2">
                  <span className="text-green-400">‚úì</span>
                  <span>Check "Data Received" tab for transfer history</span>
                </p>
                <p className="flex items-start gap-2">
                  <span className="text-green-400">‚úì</span>
                  <span>
                    Ask sender to confirm the correct receiver address
                  </span>
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Documents Grid */}
        {!isLoadingDocs && msg.length > 0 && (
          <>
            {/* Warning banner when no metadata exists */}
            {Object.keys(docMetadata).length === 0 && (
              <div className="mb-6 bg-yellow-900/30 border border-yellow-500/50 rounded-lg p-6">
                <div className="flex items-start gap-4">
                  <div className="text-4xl">‚ö†Ô∏è</div>
                  <div className="flex-1">
                    <h3 className="text-yellow-300 font-bold text-lg mb-2">
                      No Patient Information Available
                    </h3>
                    <p className="text-yellow-200 text-sm mb-3">
                      Your documents are visible, but patient information (name, ID, document type) is not stored.
                    </p>
                    <div className="space-y-2 text-sm text-gray-300">
                      <p className="flex items-start gap-2">
                        <span className="text-yellow-400">‚Ä¢</span>
                        <span>Upload new documents using the <strong className="text-white">"Document Transfer"</strong> page and fill in patient details</span>
                      </p>
                      <p className="flex items-start gap-2">
                        <span className="text-yellow-400">‚Ä¢</span>
                        <span>Existing documents will show CID only</span>
                      </p>
                      <p className="flex items-start gap-2">
                        <span className="text-yellow-400">‚Ä¢</span>
                        <span>Click <button onClick={handleShowCacheInfo} className="text-blue-400 underline hover:text-blue-300">üìä Cache Info</button> to check stored data</span>
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            )}

            <div className="flex flex-wrap gap-10 mb-10">
            {msg.map((item, index) => {
              const metadata = docMetadata[item.cid] || {};
              return (
                <div
                  className="block relative p-0.5 bg-no-repeat bg-[length:100%_100%] md:max-w-[24rem]"
                  key={index}
                  onClick={() => handleBoxClick(item)}
                >
                  <div className="relative z-2 flex flex-col min-h-[12rem] p-[2.4rem] cursor-pointer">
                    {/* Received/Uploaded Badge */}
                    {item.isReceived && (
                      <div className="absolute top-3 right-3 px-2 py-1 bg-green-900/40 border border-green-500/60 rounded-full text-xs text-green-300 font-semibold">
                        üì• Received
                      </div>
                    )}

                    {/* Patient Info Header */}
                    {metadata.patientName && (
                      <div className="mb-3 pb-3 border-b border-zinc-700">
                        <h4 className="text-lg font-bold text-purple-400 mb-1">
                          üë§ {metadata.patientName}
                        </h4>
                        {metadata.patientId && metadata.patientId !== "N/A" && (
                          <p className="text-xs text-gray-400">
                            ID: {metadata.patientId}
                          </p>
                        )}
                        {metadata.documentType && (
                          <span className="inline-block mt-1 px-2 py-1 bg-orange-900/30 border border-orange-500/50 rounded text-xs text-orange-300">
                            {metadata.documentType}
                          </span>
                        )}
                      </div>
                    )}

                    <h5 className="text-xs font-bold text-orange-500 mb-2">
                      {metadata.patientName
                        ? "Document Details"
                        : `Document #${index + 1}`}
                    </h5>
                    <p className="text-sm mb-2 text-gray-400 break-all">
                      <span className="font-semibold">CID:</span>{" "}
                      {item.cid.substring(0, 20)}...
                    </p>
                    <p className="text-sm mb-2 text-gray-400">
                      <span className="font-semibold">From:</span>{" "}
                      {item.sender?.substring(0, 10)}...
                    </p>
                    <p className="text-sm mb-2 text-gray-400">
                      <span className="font-semibold">To:</span>{" "}
                      {item.receiver?.substring(0, 10)}...
                    </p>
                    <p className="body-2 mb-6 text-n-3">
                      {convertUTC(item.timestamp)}
                    </p>
                    <div className="flex flex-col gap-2 mt-auto">
                      <div className="flex items-center">
                        <img
                          src={benefitIcon3}
                          width={48}
                          height={48}
                          alt="document"
                        />
                        <p className="ml-auto font-code text-xs hover:underline font-bold text-n-1 uppercase tracking-wider">
                          Open document
                        </p>
                        <Arrow />
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                        <button
                          onClick={(e) => handleAnalyzeWithAI(item, e)}
                          className="px-3 py-2 bg-gradient-to-r from-blue-500 to-purple-600 text-white font-bold rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all text-xs"
                        >
                          ü§ñ Analyze AI
                        </button>
                        <button
                          onClick={(e) => handleDeleteDocument(item, e)}
                          className="px-3 py-2 bg-gradient-to-r from-red-500 to-red-700 text-white font-bold rounded-lg hover:from-red-600 hover:to-red-800 transition-all text-xs"
                        >
                          üóëÔ∏è Delete
                        </button>
                      </div>
                    </div>
                  </div>

                  <GradientLight />

                  <div
                    className="absolute inset-0.5 bg-zinc-800"
                    style={{ clipPath: "url(#benefits)" }}
                  >
                    <div className="absolute inset-0 opacity-0 transition-opacity hover:opacity-90">
                      <img
                        src={benefitImage2}
                        width={380}
                        className="w-full h-full object-cover"
                      />
                    </div>
                  </div>
                  <ClipPath />
                </div>
              );
            })}
          </div>
          </>
        )}
      </div>

      {isPopupOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 p-4">
          <div className="w-full max-w-6xl bg-zinc-900 rounded-lg shadow-2xl overflow-hidden border border-zinc-700">
            <div className="flex items-center justify-between p-6 border-b border-zinc-700 bg-zinc-800">
              <h5 className="text-2xl font-bold text-white flex items-center gap-2">
                ü§ñ AI Medical Image Analysis
              </h5>
              <button
                onClick={handleCloseAnalysis}
                type="button"
                className="text-gray-400 hover:text-white transition-colors"
              >
                <IoCloseSharp size={28} />
              </button>
            </div>

            <div className="p-6 max-h-[80vh] overflow-y-auto">
              {isAnalyzing ? (
                <div className="flex flex-col items-center justify-center py-12">
                  <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500 mb-4"></div>
                  <p className="text-white text-xl font-semibold">
                    Analyzing medical image...
                  </p>
                  <p className="text-gray-400 mt-2">
                    This may take a few seconds
                  </p>
                </div>
              ) : aiAnalysis ? (
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  {/* Image Preview */}
                  <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-700">
                    <h6 className="text-lg font-bold text-white mb-4">
                      Medical Image
                    </h6>
                    {aiAnalysis.imageUrl && (
                      <img
                        src={aiAnalysis.imageUrl}
                        alt="Medical scan"
                        className="w-full h-auto rounded-lg border border-zinc-600"
                      />
                    )}
                    {selectedDocument && (
                      <div className="mt-4 text-sm text-gray-400">
                        <p>
                          <span className="font-semibold">CID:</span>{" "}
                          {selectedDocument.cid.substring(0, 30)}...
                        </p>
                        <p>
                          <span className="font-semibold">Uploaded:</span>{" "}
                          {convertUTC(selectedDocument.timestamp)}
                        </p>
                      </div>
                    )}
                  </div>

                  {/* AI Analysis Results */}
                  <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-700">
                    <h6 className="text-lg font-bold text-white mb-4">
                      AI Analysis Report
                    </h6>
                    {aiAnalysis.error ? (
                      <div className="bg-red-900/30 border border-red-500 text-red-200 p-4 rounded-lg">
                        {aiAnalysis.message}
                      </div>
                    ) : (
                      <div className="prose prose-invert max-w-none">
                        <div className="text-gray-300 whitespace-pre-line leading-relaxed">
                          {aiAnalysis.message}
                        </div>
                        <div className="mt-6 p-4 bg-yellow-900/30 border border-yellow-600 rounded-lg">
                          <p className="text-yellow-200 text-sm font-semibold">
                            ‚ö†Ô∏è Medical Disclaimer:
                          </p>
                          <p className="text-yellow-300 text-xs mt-2">
                            This AI analysis is for informational purposes only
                            and should not replace professional medical advice,
                            diagnosis, or treatment. Always consult with a
                            qualified healthcare provider for medical decisions.
                          </p>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              ) : (
                <div className="text-center py-12">
                  <p className="text-gray-400">No analysis available</p>
                </div>
              )}
            </div>

            <div className="flex justify-end gap-3 p-6 border-t border-zinc-700 bg-zinc-800">
              <button
                onClick={handleCloseAnalysis}
                className="px-6 py-2 bg-gray-600 text-white font-semibold rounded-lg hover:bg-gray-700 transition-all"
              >
                Close
              </button>
              {aiAnalysis && !aiAnalysis.error && (
                <button
                  onClick={() => window.print()}
                  className="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-all"
                >
                  Print Report
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </Section>
  );
};

export default Dashboard;
